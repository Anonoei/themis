"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KEYTYPE_RSA = exports.KEYTYPE_EC = exports.COMPARATOR_NOT_READY = exports.COMPARATOR_NOT_MATCH = exports.COMPARATOR_MATCH = exports.COMPARATOR_ERROR = void 0;
exports.comparatorBegin = comparatorBegin;
exports.comparatorInit64 = comparatorInit64;
exports.comparatorProceed64 = comparatorProceed64;
exports.isBase64 = isBase64;
exports.keyPair64 = keyPair64;
exports.secureCellContextImprintDecrypt64 = secureCellContextImprintDecrypt64;
exports.secureCellContextImprintEncrypt64 = secureCellContextImprintEncrypt64;
exports.secureCellSealWithPassphraseDecrypt64 = secureCellSealWithPassphraseDecrypt64;
exports.secureCellSealWithPassphraseEncrypt64 = secureCellSealWithPassphraseEncrypt64;
exports.secureCellSealWithSymmetricKeyDecrypt64 = secureCellSealWithSymmetricKeyDecrypt64;
exports.secureCellSealWithSymmetricKeyEncrypt64 = secureCellSealWithSymmetricKeyEncrypt64;
exports.secureCellTokenProtectDecrypt64 = secureCellTokenProtectDecrypt64;
exports.secureCellTokenProtectEncrypt64 = secureCellTokenProtectEncrypt64;
exports.secureMessageDecrypt64 = secureMessageDecrypt64;
exports.secureMessageEncrypt64 = secureMessageEncrypt64;
exports.secureMessageSign64 = secureMessageSign64;
exports.secureMessageVerify64 = secureMessageVerify64;
exports.string64 = string64;
exports.symmetricKey64 = symmetricKey64;

var _reactNative = require("react-native");

var _buffer = require("buffer");

const LINKING_ERROR = `The package 'react-native-themis' doesn't seem to be linked. Make sure: \n\n` + _reactNative.Platform.select({
  ios: "- You have run 'pod install'\n",
  default: ''
}) + '- You rebuilt the app after installing the package\n' + '- You are not using Expo managed workflow\n';
const Themis = _reactNative.NativeModules.Themis ? _reactNative.NativeModules.Themis : new Proxy({}, {
  get() {
    throw new Error(LINKING_ERROR);
  }

});
const {
  COMPARATOR_NOT_READY,
  COMPARATOR_NOT_MATCH,
  COMPARATOR_MATCH,
  COMPARATOR_ERROR,
  KEYTYPE_RSA,
  KEYTYPE_EC
} = Themis.getConstants();
exports.KEYTYPE_EC = KEYTYPE_EC;
exports.KEYTYPE_RSA = KEYTYPE_RSA;
exports.COMPARATOR_ERROR = COMPARATOR_ERROR;
exports.COMPARATOR_MATCH = COMPARATOR_MATCH;
exports.COMPARATOR_NOT_MATCH = COMPARATOR_NOT_MATCH;
exports.COMPARATOR_NOT_READY = COMPARATOR_NOT_READY;

function isBase64(str) {
  const regex64 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  return regex64.test(str);
}

function string64(input) {
  return _buffer.Buffer.from(input).toString('base64');
}

function keyPair64() {
  let typeOfKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : KEYTYPE_EC;

  if (typeOfKey !== KEYTYPE_RSA && typeOfKey !== KEYTYPE_EC) {
    throw new Error('Invalid key type');
  }

  return new Promise(resolve => {
    Themis.keyPair(typeOfKey, pair => {
      const pvtKey64 = _buffer.Buffer.from(new Uint8Array(pair.private)).toString("base64");

      const pubKey64 = _buffer.Buffer.from(new Uint8Array(pair.public)).toString("base64");

      resolve({
        private64: pvtKey64,
        public64: pubKey64
      });
    });
  });
}

;

function symmetricKey64() {
  return new Promise(resolve => {
    Themis.symmetricKey(key => {
      resolve(_buffer.Buffer.from(new Uint8Array(key)).toString("base64"));
    });
  });
}

;

function secureCellSealWithSymmetricKeyEncrypt64(symmetricKey64, plaintext) {
  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  if (plaintext === "" || plaintext === undefined || plaintext === null) {
    throw new Error("Parameter plaintext can not be empty");
  }

  if (symmetricKey64 === "" || symmetricKey64 === undefined || symmetricKey64 === null) {
    throw new Error("Parameter symmetricKey64 can not be empty");
  }

  if (!isBase64(symmetricKey64)) {
    throw new Error("Parameter symmetricKey64 is not base64 encoded");
  }

  const symmetricKey = Array.from(_buffer.Buffer.from(symmetricKey64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureCellSealWithSymmetricKeyEncrypt(symmetricKey, plaintext, context, encrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(encrypted)).toString("base64"));
    }, error => {
      reject(error);
    });
  });
}

;

function secureCellSealWithSymmetricKeyDecrypt64(symmetricKey64, encrypted64) {
  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  if (symmetricKey64 === "" || symmetricKey64 === undefined || symmetricKey64 === null) {
    throw new Error("Parameter symmetricKey64 can not be empty");
  }

  if (encrypted64 === "" || encrypted64 === undefined || encrypted64 === null) {
    throw new Error("Parameter encrypted64 can not be empty");
  }

  if (!isBase64(symmetricKey64)) {
    throw new Error("Parameter symmetricKey64 is not base64 encoded");
  }

  if (!isBase64(encrypted64)) {
    throw new Error("Parameter encrypted64 is not base64 encoded");
  }

  const symmetricKey = Array.from(_buffer.Buffer.from(symmetricKey64, 'base64'));
  const encrypted = Array.from(_buffer.Buffer.from(encrypted64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureCellSealWithSymmetricKeyDecrypt(symmetricKey, encrypted, context, decrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(decrypted)).toString());
    }, error => {
      reject(error);
    });
  });
}

;

function secureCellSealWithPassphraseEncrypt64(passphrase, plaintext) {
  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  if (passphrase === "" || passphrase === undefined || passphrase === null) {
    throw new Error("Parameter passphrase can not be empty");
  }

  if (plaintext === "" || plaintext === undefined || plaintext === null) {
    throw new Error("Parameter plaintext can not be empty");
  }

  return new Promise((resolve, reject) => {
    Themis.secureCellSealWithPassphraseEncrypt(passphrase, plaintext, context, encrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(encrypted)).toString("base64"));
    }, error => {
      reject(error);
    });
  });
}

;

function secureCellSealWithPassphraseDecrypt64(passphrase, encrypted64) {
  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  if (passphrase === "" || passphrase === undefined || passphrase === null) {
    throw new Error("Parameter passphrase can not be empty");
  }

  if (encrypted64 === "" || encrypted64 === undefined || encrypted64 === null) {
    throw new Error("Parameter encrypted64 can not be empty");
  }

  if (!isBase64(encrypted64)) {
    throw new Error("Parameter encrypted64 is not base64 encoded");
  }

  const encrypted = Array.from(_buffer.Buffer.from(encrypted64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureCellSealWithPassphraseDecrypt(passphrase, encrypted, context, decrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(decrypted)).toString());
    }, error => {
      reject(error);
    });
  });
}

function secureCellTokenProtectEncrypt64(symmetricKey64, plaintext) {
  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  if (symmetricKey64 === "" || symmetricKey64 === undefined || symmetricKey64 === null) {
    throw new Error("Parameter symmetricKey64 can not be empty");
  }

  if (plaintext === "" || plaintext === undefined || plaintext === null) {
    throw new Error("Parameter plaintext can not be empty");
  }

  if (!isBase64(symmetricKey64)) {
    throw new Error("Parameter symmetricKey64 is not base64 encoded");
  }

  const symmetricKey = Array.from(_buffer.Buffer.from(symmetricKey64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureCellTokenProtectEncrypt(symmetricKey, plaintext, context, encrypted => {
      const data = _buffer.Buffer.from(new Uint8Array(encrypted.encrypted)).toString("base64");

      const token = _buffer.Buffer.from(new Uint8Array(encrypted.token)).toString("base64");

      resolve({
        encrypted64: data,
        token64: token
      });
    }, error => {
      reject(error);
    });
  });
}

function secureCellTokenProtectDecrypt64(symmetricKey64, encrypted64, token64) {
  let context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

  if (symmetricKey64 === "" || symmetricKey64 === undefined || symmetricKey64 === null) {
    throw new Error("Parameter symmetricKey64 can not be empty");
  }

  if (encrypted64 === "" || encrypted64 === undefined || encrypted64 === null) {
    throw new Error("Parameter encrypted64 can not be empty");
  }

  if (token64 === "" || token64 === undefined || token64 === null) {
    throw new Error("Parameter token64 can not be empty");
  }

  if (!isBase64(symmetricKey64)) {
    throw new Error("Parameter symmetricKey64 is not base64 encoded");
  }

  if (!isBase64(encrypted64)) {
    throw new Error("Parameter encrypted64 is not base64 encoded");
  }

  if (!isBase64(token64)) {
    throw new Error("Parameter token64 is not base64 encoded");
  }

  const symmetricKey = Array.from(_buffer.Buffer.from(symmetricKey64, 'base64'));
  const encrypted = Array.from(_buffer.Buffer.from(encrypted64, 'base64'));
  const token = Array.from(_buffer.Buffer.from(token64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureCellTokenProtectDecrypt(symmetricKey, encrypted, token, context, decrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(decrypted)).toString());
    }, error => {
      reject(error);
    });
  });
} // context imprint encrypt and decrypt


function secureCellContextImprintEncrypt64(symmetricKey64, plaintext, context) {
  if (symmetricKey64 === "" || symmetricKey64 === undefined || symmetricKey64 === null) {
    throw new Error("Parameter symmetricKey64 can not be empty");
  }

  if (plaintext === "" || plaintext === undefined || plaintext === null) {
    throw new Error("Parameter plaintext can not be empty");
  }

  if (context === "" || context === undefined || context === null) {
    throw new Error("Parameter context can not be empty");
  }

  if (!isBase64(symmetricKey64)) {
    throw new Error("Parameter symmetricKey64 is not base64 encoded");
  }

  const symmetricKey = Array.from(_buffer.Buffer.from(symmetricKey64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureCellContextImprintEncrypt(symmetricKey, plaintext, context, encrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(encrypted)).toString("base64"));
    }, error => {
      reject(error);
    });
  });
}

function secureCellContextImprintDecrypt64(symmetricKey64, encrypted64, context) {
  if (symmetricKey64 === "" || symmetricKey64 === undefined || symmetricKey64 === null) {
    throw new Error("Parameter symmetricKey64 can not be empty");
  }

  if (encrypted64 === "" || encrypted64 === undefined || encrypted64 === null) {
    throw new Error("Parameter encrypted64 can not be empty");
  }

  if (context === "" || context === undefined || context === null) {
    throw new Error("Parameter context can not be empty");
  }

  if (!isBase64(symmetricKey64)) {
    throw new Error("Parameter symmetricKey64 is not base64 encoded");
  }

  if (!isBase64(encrypted64)) {
    throw new Error("Parameter encrypted64 is not base64 encoded");
  }

  const symmetricKey = Array.from(_buffer.Buffer.from(symmetricKey64, 'base64'));
  const encrypted = Array.from(_buffer.Buffer.from(encrypted64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureCellContextImprintDecrypt(symmetricKey, encrypted, context, decrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(decrypted)).toString());
    }, error => {
      reject(error);
    });
  });
} // secure message sign and verify


function secureMessageSign64(plaintext, privateKey64) {
  let publicKey64 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

  if (plaintext === "" || plaintext === undefined || plaintext === null) {
    throw new Error("Parameter plaintext can not be empty");
  }

  if (privateKey64 === "" || privateKey64 === undefined || privateKey64 === null) {
    throw new Error("Parameter privateKey64 can not be empty");
  }

  if (!isBase64(privateKey64)) {
    throw new Error("Parameter privateKey64 is not base64 encoded");
  }

  const privateKey = Array.from(_buffer.Buffer.from(privateKey64, 'base64'));

  if (publicKey64 === undefined || publicKey64 === null) {
    publicKey64 = "";
  }

  if (publicKey64 && !isBase64(publicKey64)) {
    throw new Error("Optional parameter publicKey64 is not base64 encoded");
  }

  const publicKey = publicKey64 === "" ? null : Array.from(_buffer.Buffer.from(publicKey64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureMessageSign(plaintext, privateKey, publicKey, signed => {
      resolve(_buffer.Buffer.from(new Uint8Array(signed)).toString("base64"));
    }, error => {
      reject(error);
    });
  });
}

function secureMessageVerify64(signed64) {
  let privateKey64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  let publicKey64 = arguments.length > 2 ? arguments[2] : undefined;

  if (signed64 === "" || signed64 === undefined || signed64 === null) {
    throw new Error("Parameter signed64 can not be empty");
  }

  if (publicKey64 === "" || publicKey64 === undefined || publicKey64 === null) {
    throw new Error("Parameter publicKey64 can not be empty");
  }

  if (!isBase64(signed64)) {
    throw new Error("Parameter signed64 is not base64 encoded");
  }

  if (!isBase64(publicKey64)) {
    throw new Error("Parameter publicKey64 is not base64 encoded");
  }

  const publicKey = Array.from(_buffer.Buffer.from(publicKey64, 'base64'));

  if (privateKey64 === undefined || privateKey64 === null) {
    privateKey64 = "";
  }

  if (privateKey64 && !isBase64(privateKey64)) {
    throw new Error("Optional parameter privateKey64 is not base64 encoded");
  }

  const privateKey = privateKey64 === "" ? null : Array.from(_buffer.Buffer.from(privateKey64, 'base64'));
  const signed = Array.from(_buffer.Buffer.from(signed64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureMessageVerify(signed, privateKey, publicKey, verified => {
      resolve(_buffer.Buffer.from(new Uint8Array(verified)).toString());
    }, error => {
      reject(error);
    });
  });
} // secure message encrypt and decrypt


function secureMessageEncrypt64(plaintext, privateKey64, publicKey64) {
  if (plaintext === "" || plaintext === undefined || plaintext === null) {
    throw new Error("Parameter plaintext can not be empty");
  }

  if (privateKey64 === "" || privateKey64 === undefined || privateKey64 === null) {
    throw new Error("Parameter privateKey64 can not be empty");
  }

  if (publicKey64 === "" || publicKey64 === undefined || publicKey64 === null) {
    throw new Error("Parameter publicKey64 can not be empty");
  }

  if (!isBase64(privateKey64)) {
    throw new Error("Parameter privateKey64 is not base64 encoded");
  }

  if (!isBase64(publicKey64)) {
    throw new Error("Parameter publicKey64 is not base64 encoded");
  }

  const privateKey = Array.from(_buffer.Buffer.from(privateKey64, 'base64'));
  const publicKey = Array.from(_buffer.Buffer.from(publicKey64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureMessageEncrypt(plaintext, privateKey, publicKey, encrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(encrypted)).toString("base64"));
    }, error => {
      reject(error);
    });
  });
}

function secureMessageDecrypt64(encrypted64, privateKey64, publicKey64) {
  if (encrypted64 === "" || encrypted64 === undefined || encrypted64 === null) {
    throw new Error("Parameter encrypted64 can not be empty");
  }

  if (privateKey64 === "" || privateKey64 === undefined || privateKey64 === null) {
    throw new Error("Parameter privateKey64 can not be empty");
  }

  if (publicKey64 === "" || publicKey64 === undefined || publicKey64 === null) {
    throw new Error("Parameter publicKey64 can not be empty");
  }

  if (!isBase64(encrypted64)) {
    throw new Error("Parameter encrypted64 is not base64 encoded");
  }

  if (!isBase64(privateKey64)) {
    throw new Error("Parameter privateKey64 is not base64 encoded");
  }

  if (!isBase64(publicKey64)) {
    throw new Error("Parameter publicKey64 is not base64 encoded");
  }

  const encrypted = Array.from(_buffer.Buffer.from(encrypted64, 'base64'));
  const privateKey = Array.from(_buffer.Buffer.from(privateKey64, 'base64'));
  const publicKey = Array.from(_buffer.Buffer.from(publicKey64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.secureMessageDecrypt(encrypted, privateKey, publicKey, decrypted => {
      resolve(_buffer.Buffer.from(new Uint8Array(decrypted)).toString());
    }, error => {
      reject(error);
    });
  });
}
/* Returns UUID in string value that corresponds to new comparator */


function comparatorInit64(data64) {
  if (data64 === "" || data64 === undefined || data64 === null) {
    throw new Error("Parameter data64 can not be empty");
  }

  if (!isBase64(data64)) {
    throw new Error("Parameter data64 is not base64 encoded");
  }

  const data = Array.from(_buffer.Buffer.from(data64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.initComparator(data, comparator => {
      resolve(comparator);
    }, error => {
      reject(error);
    });
  });
}

function comparatorBegin(uuidStr) {
  if (uuidStr === "" || uuidStr === undefined || uuidStr === null) {
    throw new Error("Parameter uuidStr can not be empty");
  }

  return new Promise((resolve, reject) => {
    Themis.beginCompare(uuidStr, data => {
      resolve(_buffer.Buffer.from(new Uint8Array(data)).toString("base64"));
    }, error => {
      reject(error);
    });
  });
}
/* Returns next part of data and current status */


function comparatorProceed64(uuidStr, data64) {
  if (uuidStr === "" || uuidStr === undefined || uuidStr === null) {
    throw new Error("Parameter uuidStr can not be empty");
  }

  if (data64 === "" || data64 === undefined || data64 === null) {
    throw new Error("Parameter data64 can not be empty");
  }

  if (!isBase64(data64)) {
    throw new Error("Parameter data64 is not base64 encoded");
  }

  const data = Array.from(_buffer.Buffer.from(data64, 'base64'));
  return new Promise((resolve, reject) => {
    Themis.proceedCompare(uuidStr, data, (nextData, status) => {
      const nextdata64 = _buffer.Buffer.from(new Uint8Array(nextData)).toString("base64");

      resolve({
        data64: nextdata64,
        status: status
      });
    }, error => {
      reject(error);
    });
  });
}
//# sourceMappingURL=index.js.map